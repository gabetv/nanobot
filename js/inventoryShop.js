// js/inventoryShop.js

function gainXP(amount) { let stats = gameState.nanobotStats; if (!stats.level) { stats.level = 1; stats.xp = 0; stats.xpToNext = 100; } stats.xp += amount; while (stats.xp >= stats.xpToNext) { stats.xp -= stats.xpToNext; stats.level++; stats.xpToNext = Math.floor(stats.xpToNext * 1.5); addLogEntry("Niveau atteint: " + stats.level, "success", combatLogSummaryEl, gameState.combatLogSummary); stats.baseAttack += 2; stats.baseDefense += 1; stats.baseHealth += 10; calculateNanobotStats(); } updateXpBar(); xpGainEl.textContent = `+${amount} XP (Niv. ${stats.level})`; }

function generateLoot(enemyDetails) { const possibleLootItems = ['comp_av', 'crist_stock', 'mod_proto', 'frag_alien']; let results = []; if (Math.random() < 0.6) { results.push(possibleLootItems[Math.floor(Math.random() * possibleLootItems.length)]); } if (Math.random() < 0.15) { results.push('arte_rare'); } if (Math.random() < 0.05) { results.push('item_laser_mk1'); } if (Math.random() < 0.08) { results.push('item_plating_basic'); } return results; }

function addToInventory(itemId) { if (!itemsData[itemId]) { console.warn(`Tentative d'ajout d'un objet inconnu à l'inventaire: ${itemId}`); return; } gameState.inventory.push(itemId); updateInventoryDisplay(); addLogEntry(`Objet reçu: ${itemsData[itemId].name}`, "success"); }

function removeFromInventory(itemId) { const index = gameState.inventory.indexOf(itemId); if (index > -1) { gameState.inventory.splice(index, 1); updateInventoryDisplay(); return true; } return false; }

function updateInventoryDisplay() { if (!inventoryListEl) return; inventoryListEl.innerHTML = ""; if (gameState.inventory.length === 0) { inventoryListEl.innerHTML = "<p class='text-gray-500 italic'>L'inventaire est vide.</p>"; return; } const itemCounts = gameState.inventory.reduce((acc, itemId) => { acc[itemId] = (acc[itemId] || 0) + 1; return acc; }, {}); Object.entries(itemCounts).forEach(([itemId, count]) => { const item = itemsData[itemId]; if (!item) return; const li = document.createElement("li"); li.className = "inventory-item"; let content = `<div class="item-details"><span class="item-name">${item.name} ${count > 1 ? `(x${count})` : ''}</span><p class="item-stats">${item.description}</p>`; if (item.statBoost) { content += `<p class="item-stats">Stats: ${Object.entries(item.statBoost).map(([s,v]) => `${s.charAt(0).toUpperCase()+s.slice(1)}: ${v > 0 ? '+' : ''}${v}`).join(', ')}</p>`; } content += `</div>`; if (item.slot) { content += `<button class="btn btn-primary btn-sm" onclick="equipItem('${item.id}')">Équiper</button>`; } li.innerHTML = content; inventoryListEl.appendChild(li); }); }

function equipItem(itemId) { const item = itemsData[itemId]; if (!item || !item.slot) { addLogEntry("Cet objet ne peut pas être équipé.", "warning"); return; } const currentEquippedItemId = gameState.nanobotEquipment[item.slot]; if (currentEquippedItemId) { addToInventory(currentEquippedItemId); } gameState.nanobotEquipment[item.slot] = itemId; removeFromInventory(itemId); addLogEntry(`${item.name} équipé sur ${EQUIPMENT_SLOTS[item.slot]}.`, "success"); calculateNanobotStats(); updateDisplays(); }

function unequipItem(slotId) { const itemId = gameState.nanobotEquipment[slotId]; if (itemId && itemsData[itemId]) { const item = itemsData[itemId]; addToInventory(itemId); gameState.nanobotEquipment[slotId] = null; addLogEntry(`${item.name} retiré de ${EQUIPMENT_SLOTS[slotId]}.`, "info"); calculateNanobotStats(); updateDisplays(); } }

function updateShopDisplay() { shopItemsListEl.innerHTML = ""; if (gameState.shopStock.length === 0) { shopItemsListEl.innerHTML = "<p class='text-gray-500 italic'>La boutique est actuellement vide.</p>"; return; } gameState.shopStock.forEach(itemId => { const item = itemsData[itemId]; if (!item || !item.cost) return; const li = document.createElement("div"); li.className = "shop-item panel"; let costString = Object.entries(item.cost).map(([res, val]) => `${val} ${res.charAt(0).toUpperCase() + res.slice(1)}`).join(', '); let canAfford = true; for (const resource in item.cost) { if (gameState.resources[resource] < item.cost[resource]) { canAfford = false; break; } } let content = `<div class="item-details"><h4 class="item-name text-lg text-blue-300">${item.name}</h4><p class="item-stats text-sm text-gray-400">${item.description}</p>`; if (item.statBoost) { content += `<p class="item-stats text-sm text-green-300">Effets: ${Object.entries(item.statBoost).map(([s,v]) => `${s.charAt(0).toUpperCase()+s.slice(1)}: ${v > 0 ? '+' : ''}${v}`).join(', ')}</p>`; } content += `<p class="text-sm text-yellow-400 mt-1">Coût: ${costString}</p></div>`; content += `<button class="btn ${canAfford ? 'btn-success' : 'btn-disabled'} btn-sm mt-2" onclick="buyItem('${item.id}')" ${!canAfford ? 'disabled' : ''}>Acheter</button>`; li.innerHTML = content; shopItemsListEl.appendChild(li); }); }

function buyItem(itemId) { const item = itemsData[itemId]; if (!item || !item.cost) { addLogEntry("Objet non disponible à l'achat.", "error"); return; } for (const resource in item.cost) { if (gameState.resources[resource] < item.cost[resource]) { addLogEntry(`Ressources insuffisantes pour acheter ${item.name}.`, "error"); return; } } for (const resource in item.cost) { gameState.resources[resource] -= item.cost[resource]; } addToInventory(itemId); addLogEntry(`${item.name} acheté !`, "success"); updateResourceDisplay(); updateShopDisplay(); }