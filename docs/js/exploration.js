// js/exploration.js
// (Collez le contenu de js/exploration.js de la réponse précédente ici)
function generateMap() { gameState.map.tiles = []; gameState.map.explored = []; for (let y = 0; y < MAP_SIZE.height; y++) { const tileRow = []; const exploredRow = []; for (let x = 0; x < MAP_SIZE.width; x++) { tileRow.push(TILE_TYPES.EMPTY); exploredRow.push(false); } gameState.map.tiles.push(tileRow); gameState.map.explored.push(exploredRow); } gameState.map.tiles[BASE_COORDINATES.y][BASE_COORDINATES.x] = TILE_TYPES.BASE; gameState.map.explored[BASE_COORDINATES.y][BASE_COORDINATES.x] = true; for (let i = 0; i < 5; i++) { let rx, ry; do { rx = Math.floor(Math.random() * MAP_SIZE.width); ry = Math.floor(Math.random() * MAP_SIZE.height); } while (gameState.map.tiles[ry][rx] !== TILE_TYPES.EMPTY); gameState.map.tiles[ry][rx] = { type: TILE_TYPES.RESOURCE_BIOMASS, amount: Math.floor(Math.random() * 50) + 20 };} for (let i = 0; i < 3; i++) { let rx, ry; do { rx = Math.floor(Math.random() * MAP_SIZE.width); ry = Math.floor(Math.random() * MAP_SIZE.height); } while (gameState.map.tiles[ry][rx] !== TILE_TYPES.EMPTY); gameState.map.tiles[ry][rx] = { type: TILE_TYPES.RESOURCE_NANITES, amount: Math.floor(Math.random() * 30) + 10 };} for (let i = 0; i < 4; i++) { let ex, ey; do { ex = Math.floor(Math.random() * MAP_SIZE.width); ey = Math.floor(Math.random() * MAP_SIZE.height); } while (gameState.map.tiles[ey][ex] !== TILE_TYPES.EMPTY || (ex === BASE_COORDINATES.x && ey === BASE_COORDINATES.y)); gameState.map.tiles[ey][ex] = { type: TILE_TYPES.ENEMY_DRONE, details: { name: "Drone Éclaireur", health: 30, maxHealth:30, attack: 8, defense: 2, color: '#a0aec0', spritePath: 'images/enemy_drone.png' } };} let ux, uy; do { ux = Math.floor(Math.random() * MAP_SIZE.width); uy = Math.floor(Math.random() * MAP_SIZE.height); } while (gameState.map.tiles[uy][ux] !== TILE_TYPES.EMPTY || (ux === BASE_COORDINATES.x && uy === BASE_COORDINATES.y)); gameState.map.tiles[uy][ux] = { type: TILE_TYPES.UPGRADE_CACHE, reward: { biomass: 50, nanites: 25 } }; for (let i = 0; i < MAP_SIZE.width * MAP_SIZE.height * 0.1; i++) { let ix, iy; do { ix = Math.floor(Math.random() * MAP_SIZE.width); iy = Math.floor(Math.random() * MAP_SIZE.height); } while (gameState.map.tiles[iy][ix] !== TILE_TYPES.EMPTY || (ix === BASE_COORDINATES.x && iy === BASE_COORDINATES.y)); gameState.map.tiles[iy][ix] = TILE_TYPES.IMPASSABLE; } gameState.nanobotMapPos = { ...BASE_COORDINATES }; }
function getTileDisplayClass(x, y) { const isNanobotCurrentPos = gameState.map.nanobotPos.x === x && gameState.map.nanobotPos.y === y; if (isNanobotCurrentPos) return 'nanobot'; if (!gameState.map.explored[y][x]) return 'unexplored'; const tileData = gameState.map.tiles[y][x]; let tileType = tileData; if (typeof tileData === 'object' && tileData !== null) tileType = tileData.type; switch (tileType) { case TILE_TYPES.EMPTY: return 'explored'; case TILE_TYPES.BASE: return 'base'; case TILE_TYPES.RESOURCE_BIOMASS: return 'resource-biomass'; case TILE_TYPES.RESOURCE_NANITES: return 'resource-nanites'; case TILE_TYPES.ENEMY_DRONE: case TILE_TYPES.ENEMY_SAURIAN: return 'enemy'; case TILE_TYPES.UPGRADE_CACHE: return 'upgrade'; case TILE_TYPES.IMPASSABLE: return 'impassable'; default: return 'explored'; } }
function getTileInfo(x,y) { if (!gameState.map.explored[y][x]) return "Zone non explorée."; const tileData = gameState.map.tiles[y][x]; let tileType = tileData; if (typeof tileData === 'object' && tileData !== null) tileType = tileData.type; switch (tileType) { case TILE_TYPES.EMPTY: return "Zone vide."; case TILE_TYPES.BASE: return "Noyau Central - Zone sécurisée."; case TILE_TYPES.RESOURCE_BIOMASS: return `Dépôt de Biomasse (${tileData.amount}).`; case TILE_TYPES.RESOURCE_NANITES: return `Fragments de Nanites (${tileData.amount}).`; case TILE_TYPES.ENEMY_DRONE: return `Danger! ${tileData.details.name} détecté.`; case TILE_TYPES.UPGRADE_CACHE: return "Cache de matériaux détectée."; case TILE_TYPES.IMPASSABLE: return "Terrain infranchissable."; default: return "Zone explorée."; } }
function updateExplorationDisplay() { mapGridEl.innerHTML = ''; mapGridEl.style.gridTemplateColumns = `repeat(${MAP_SIZE.width}, 1fr)`; for (let y = 0; y < MAP_SIZE.height; y++) { for (let x = 0; x < MAP_SIZE.width; x++) { const tileDiv = document.createElement('div'); tileDiv.classList.add('map-tile', getTileDisplayClass(x,y)); tileDiv.dataset.x = x; tileDiv.dataset.y = y; tileDiv.addEventListener('click', () => handleTileClick(x, y)); tileDiv.addEventListener('mouseover', () => { tileInfoDisplayEl.textContent = `(${x},${y}) ${getTileInfo(x,y)}`; }); tileDiv.addEventListener('mouseout', () => { tileInfoDisplayEl.textContent = "Survolez une case explorée pour plus d'infos."; }); mapGridEl.appendChild(tileDiv); } } nanobotMapPosEl.textContent = `(${gameState.map.nanobotPos.x}, ${gameState.map.nanobotPos.y})`; }
function handleTileClick(targetX, targetY) { const currentX = gameState.map.nanobotPos.x; const currentY = gameState.map.nanobotPos.y; const dx = Math.abs(targetX - currentX); const dy = Math.abs(targetY - currentY); if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) { moveToTile(targetX, targetY); } else if (dx === 0 && dy === 0) { addLogEntry("Nexus-7 est déjà sur cette position.", "info", eventLogEl); } else { addLogEntry("Déplacement impossible: Cible trop éloignée.", "warning", eventLogEl); } }
async function moveToTile(targetX, targetY) { if (gameState.resources.energy < EXPLORATION_COST_ENERGY) { addLogEntry(`Énergie insuffisante (Requis: ${EXPLORATION_COST_ENERGY}).`, "error", eventLogEl); return; } const targetTileData = gameState.map.tiles[targetY][targetX]; let targetTileType = targetTileData; if (typeof targetTileData === 'object' && targetTileData !== null) targetTileType = targetTileData.type; if (targetTileType === TILE_TYPES.IMPASSABLE) { addLogEntry("Terrain infranchissable.", "warning", eventLogEl); if (!gameState.map.explored[targetY][targetX]) { gameState.map.explored[targetY][targetX] = true; updateExplorationDisplay(); } return; } gameState.resources.energy -= EXPLORATION_COST_ENERGY; gameState.map.nanobotPos.x = targetX; gameState.map.nanobotPos.y = targetY; const newTileWasUnexplored = !gameState.map.explored[targetY][targetX]; gameState.map.explored[targetY][targetX] = true; addLogEntry(`Déplacement vers (${targetX},${targetY}). Énergie: -${EXPLORATION_COST_ENERGY}.`, "info", eventLogEl); if (newTileWasUnexplored) { addLogEntry(`Nouvelle zone découverte!`, "success", eventLogEl); } 
    if (gameState.nanobotStats.isDefendingBase && (targetX !== BASE_COORDINATES.x || targetY !== BASE_COORDINATES.y)) {
        addLogEntry("Nexus-7 quitte la zone du Noyau et ne participe plus activement à sa défense.", "warning", eventLogEl);
        calculateBaseStats(); 
    }
    updateExplorationDisplay(); updateResourceDisplay(); await triggerTileEvent(targetX, targetY); 
}
async function triggerTileEvent(x, y) { const tileData = gameState.map.tiles[y][x]; let tileType = tileData; if (typeof tileData === 'object' && tileData !== null) tileType = tileData.type; switch (tileType) { case TILE_TYPES.RESOURCE_BIOMASS: gameState.resources.biomass += tileData.amount; addLogEntry(`Biomasse trouvée (+${tileData.amount})!`, "success", eventLogEl); gameState.map.tiles[y][x] = TILE_TYPES.EMPTY; break; case TILE_TYPES.RESOURCE_NANITES: gameState.resources.nanites += tileData.amount; addLogEntry(`Nanites trouvés (+${tileData.amount})!`, "success", eventLogEl); gameState.map.tiles[y][x] = TILE_TYPES.EMPTY; break; case TILE_TYPES.ENEMY_DRONE: case TILE_TYPES.ENEMY_SAURIAN: addLogEntry(`Danger! ${tileData.details.name} rencontré!`, "warning", eventLogEl); gameState.map.currentEnemyEncounter = { x, y, details: tileData.details }; await simulateCombat(tileData.details); break; case TILE_TYPES.UPGRADE_CACHE: const reward = tileData.reward; if (reward.biomass) gameState.resources.biomass += reward.biomass; if (reward.nanites) gameState.resources.nanites += reward.nanites; addLogEntry(`Cache ouverte! +${reward.biomass || 0} Biomasse, +${reward.nanites || 0} Nanites.`, "success", eventLogEl); gameState.map.tiles[y][x] = TILE_TYPES.EMPTY; break; case TILE_TYPES.BASE: addLogEntry("Retour au Noyau Central.", "info", eventLogEl); if (gameState.nanobotStats.currentHealth < gameState.nanobotStats.health) { let healAmount = Math.ceil(gameState.nanobotStats.health * 0.1); gameState.nanobotStats.currentHealth = Math.min(gameState.nanobotStats.health, gameState.nanobotStats.currentHealth + healAmount); addLogEntry(`Nexus-7: Réparation partielle du système (+${Math.floor(healAmount)} PV).`, "info", eventLogEl); updateNanobotDisplay(); } if (gameState.nanobotStats.isDefendingBase) { addLogEntry("Nexus-7 est en position pour défendre le Noyau.", "success", eventLogEl); calculateBaseStats(); updateBaseStatusDisplay(); } break; } updateResourceDisplay(); updateExplorationDisplay(); }